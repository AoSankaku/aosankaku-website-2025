<canvas id="tetrahedron-canvas"></canvas>

<style>
  #tetrahedron-canvas {
    display: block;
    width: 100%;
    height: 250px;
    background-color: transparent;

    @media (min-width: 768px) {
      height: 400px;
    }
  }
</style>

<script>
  import * as THREE from "three";

  const canvas = document.getElementById("tetrahedron-canvas");
  if (!canvas) throw new Error("Canvas element not found");
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 1000);

  const renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true,
    alpha: true,
  });

  renderer.setSize(width, height, false);

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
  scene.add(ambientLight);
  const pointLight = new THREE.PointLight(0xffffff, 30);
  pointLight.position.set(0, 6, 7);
  scene.add(pointLight);

  const updateLightIntensity = () => {
    const isDarkMode = document.documentElement.classList.contains("dark");

    let newIntensity;
    if (isDarkMode) {
      newIntensity = 0.3;
    } else {
      newIntensity = 8;
    }

    ambientLight.intensity = newIntensity;
  };

  updateLightIntensity();

  const radius = 1;
  const detail = 0;
  const geometry = new THREE.TetrahedronGeometry(radius, detail);

  const upAxis = new THREE.Vector3(1, 0, -1).normalize();
  const angle = Math.atan(Math.sqrt(2));
  const rotationMatrix = new THREE.Matrix4().makeRotationAxis(upAxis, angle);
  geometry.applyMatrix4(rotationMatrix);

  const distanceToBase = radius / 3;
  geometry.translate(0, distanceToBase, 0);

  // Material and Mesh
  const material = new THREE.MeshStandardMaterial({
    color: 0x0077ff,
    metalness: 0.8,
    roughness: 0.35,
    wireframe: false,
  });

  const tetrahedron = new THREE.Mesh(geometry, material);
  scene.add(tetrahedron);

  camera.position.z = 5.2;
  camera.position.y = 0.5;

  const animate = () => {
    requestAnimationFrame(animate);
    tetrahedron.rotation.x = Math.PI / 36;
    tetrahedron.rotation.y += 0.002;
    renderer.render(scene, camera);
  };

  window.addEventListener("resize", () => {
    const newWidth = canvas.clientWidth;
    const newHeight = canvas.clientHeight;
    camera.aspect = newWidth / newHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(newWidth, newHeight, false);
  });

  document.addEventListener("click", () => {
    updateLightIntensity();
  });

  animate();
</script>
