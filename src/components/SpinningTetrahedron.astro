<canvas id="tetrahedron-canvas"></canvas>

<style>
  #tetrahedron-canvas {
    display: block;
    width: 100%;
    height: 250px;
    background-color: transparent;

    @media (min-width: 768px) {
      height: 400px;
    }
  }
</style>

<script>
  const init = async () => {
    const canvas = document.getElementById("tetrahedron-canvas");
    if (!canvas) throw new Error("Canvas element not found");

    const {
      Scene,
      PerspectiveCamera,
      WebGLRenderer,
      TetrahedronGeometry,
      MeshStandardMaterial,
      Mesh,
      AmbientLight,
      PointLight,
      Vector3,
      Matrix4,
    } = await import("three");

    const rect = canvas.getBoundingClientRect();
    let width = rect.width;
    let height = rect.height;

    const scene = new Scene();
    const camera = new PerspectiveCamera(35, width / height, 0.1, 1000);

    const renderer = new WebGLRenderer({
      canvas: canvas,
      antialias: true,
      alpha: true,
      powerPreference: "high-performance", // Optimization
    });

    renderer.setPixelRatio(window.devicePixelRatio); // Better sharpness
    renderer.setSize(width, height, false);

    const ambientLight = new AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);
    const pointLight = new PointLight(0xffffff, 30);
    pointLight.position.set(0, 6, 7);
    scene.add(pointLight);

    const updateLightIntensity = () => {
      const isDarkMode = document.documentElement.classList.contains("dark");

      let newIntensity;
      if (isDarkMode) {
        newIntensity = 0.3;
      } else {
        newIntensity = 8;
      }

      ambientLight.intensity = newIntensity;
    };

    updateLightIntensity();

    const radius = 1;
    const detail = 0;
    const geometry = new TetrahedronGeometry(radius, detail);

    const upAxis = new Vector3(1, 0, -1).normalize();
    const angle = Math.atan(Math.sqrt(2));
    const rotationMatrix = new Matrix4().makeRotationAxis(upAxis, angle);
    geometry.applyMatrix4(rotationMatrix);

    const distanceToBase = radius / 3;
    geometry.translate(0, distanceToBase, 0);

    // Material and Mesh
    const material = new MeshStandardMaterial({
      color: 0x0077ff,
      metalness: 0.8,
      roughness: 0.35,
      wireframe: false,
    });

    const tetrahedron = new Mesh(geometry, material);
    scene.add(tetrahedron);

    camera.position.z = 5.2;
    camera.position.y = 0.5;

    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        // Use the entry data directly instead of querying the DOM
        const { inlineSize: newWidth, blockSize: newHeight } =
          entry.contentBoxSize[0];

        camera.aspect = newWidth / newHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(newWidth, newHeight, false);
      }
    });

    resizeObserver.observe(canvas);

    const animate = () => {
      requestAnimationFrame(animate);
      tetrahedron.rotation.y += 0.002;
      renderer.render(scene, camera);
    };

    animate();
  };

  window.addEventListener("load", () => {
    if (window.requestIdleCallback) {
      window.requestIdleCallback(() => init());
    } else {
      window.setTimeout(init, 200);
    }
  });
</script>
